Сумо Игра - Архитектура проекта

Main.java - Главный контроллер приложения
Назначение: Точка входа и центральный координатор всего приложения.
Архитектурная роль:
Управление жизненным циклом JavaFX приложения
Навигация между экранами
Создание и управление GameController
Обработка ошибок и исключений

GameRenderer.java - Контроллер отрисовки игры
Назначение: Визуальное представление игрового состояния на Canvas.
Архитектурная роль:
Отделяет логику игры от её визуализации
Преобразует игровые объекты (Player, Arena) в графические примитивы
Управляет анимациями и эффектами
Обрабатывает масштабирование для разных размеров экрана

┌─────────────────────────────────────────────────────────────┐
│                      Main.java                              │
│  (управление навигацией и жизненным циклом)                │
└──────┬───────────────────────┬─────────────────────────────┘
│                       │
▼                       ▼
┌─────────────────┐   ┌─────────────────────────────────┐
│CharacterSelection│   │      GameScreenController      │
│Controller        │   │  (обработка ввода, UI обновление)│
└────────┬─────────┘   └──────────────┬──────────────────┘
│                            │
▼                            ▼
┌─────────────────┐        ┌─────────────────────────────┐
│   startAsServer()│        │       GameController       │
│  startAsClient() │        │ (медиатор: UI ↔ логика ↔ сеть)│
└─────────────────┘        └──────────────┬──────────────┘
│
┌────────────────┼────────────────┐
▼                ▼                ▼
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│  GameEngine  │  │NetworkManager│  │ GameRenderer │
│  (логика)    │  │   (сеть)     │  │ (графика)    │
└──────────────┘  └──────────────┘  └──────────────┘

CharacterSelectionController.java - Выбор персонажа
Назначение:
Первоначальный экран приложения, где пользователь выбирает персонажа и режим игры (сервер/клиент).

GameEngine = Мозг игры
├── Управление состоянием игры (GameState)
├── Физические вычисления (движение, столкновения)
├── Логика раундов и матчей
├── Обработка таймеров
└── Координация с сетевым модулем

Сетевой слой

Message.java
Назначение: Сериализация и десериализация сетевых сообщений.
Взаимодействие:
Используется GameClient и GameServer для передачи данных
Конвертируется в JSON формат с помощью Gson
Типы сообщений: PLAYER_JOIN, PLAYER_MOVE, POWER_UP, ROUND_RESULT
Каждое сообщение содержит playerId (1 или 2) для идентификации отправителя

MessageHandler.java - Интерфейс обработчика сообщений
Назначение: Определяет контракт для обработки входящих сетевых сообщений.
Реализуется: NetworkManager


NetworkService.java - Общий интерфейс для сервера и клиента
Назначение: Унификация работы с сетевыми соединениями.
Зачем нужен?
Убирает дублирование кода в NetworkManager
Позволяет NetworkManager работать с GameServer и GameClient одинаково
определяет стандартный набор операций для сетевых служб
код на уровне интерфейсов - чисто!


GameServer.java - Серверная реализация
Назначение: Принимает подключения клиентов и управляет серверной логикой.
Архитектура:
1. startServer() → создает ServerSocket на указанном порту
2. run() → ожидает подключение клиента в отдельном потоке
3. listenForMessages() → слушает входящие сообщения
4. sendMessage() → отправляет сообщения клиенту
   Особенности:
   Порт: конфигурируется через конструктор
Потоковая модель: основной поток для подключения + отдельный для прослушивания
Автоматическая отправка своего персонажа при подключении клиента
Player ID: всегда 1 (сервер = игрок 1)

GameClient.java - Клиентская реализация
Назначение: Подключается к серверу и управляет клиентским соединением.
Архитектура:
1. connect() → устанавливает соединение с сервером
2. run() → запускает поток для прослушивания сообщений
3. listenForMessages() → обрабатывает входящие сообщения
4. sendMessage() → отправляет сообщения серверу

NetworkManager.java - Центральный координатор сети
Назначение: Управляет всеми сетевыми операциями, связывает сеть с игровой логикой.

Архитектурная роль:
text
┌─────────────────┐    ┌─────────────────┐
│   GameEngine    │    │  GameController │
│     (логика)    │    │     (UI ↔ логика)│
└────────┬────────┘    └────────┬────────┘
│                      │
▼                      ▼
┌─────────────────────────────────────────┐
│           NetworkManager                │
│  (переводчик: игра ↔ сетевые сообщения) │
└─────────────────┬───────────────────────┘
│
┌───────────┴───────────┐
▼                       ▼
┌───────────┐           ┌───────────┐
│ GameServer│           │ GameClient│
│  или      │           │  или      │
│ GameClient│           │ GameServer│
└───────────┘           └───────────┘



Сценарий: Игрок выходит за арену (серверная сторона)
text
ШАГ 1: Физическое определение выхода (GameEngine)
───────────────────────────────────────────────
1. GameEngine.checkIfPlayerOut() → "Игрок 1 вышел!"
2. endRound(2) вызывается с winnerId=2 (победил игрок 2)

ШАГ 2: Локальная обработка завершения раунда
───────────────────────────────────────────────
3. GameEngine.endRound(2):
    - Сохраняет победителя: gameState.setRoundWinner(..., 2)
    - Обновляет счет: player2Score +1
    - Выводит: "Победитель раунда: Игрок 2"

4. GameEngine.endRound проверяет матч:
    - Если счет стал 2:0 → matchFinished=true
    - Или если сыграно 3 раунда

ШАГ 3: Сетевая синхронизация (ТОЛЬКО СЕРВЕР!)
───────────────────────────────────────────────
5. GameEngine (сервер) → gameController.notifyRoundResult(2)
   ↓
6. GameController → networkManager.notifyRoundResult(2)
   ↓
7. NetworkManager.sendRoundResult(2)
   ↓
8. GameServer.sendMessage(ROUND_RESULT, "2")
   ↓
9. Клиент получает сообщение по сети

ШАГ 4: Показ результатов матча (если матч завершен)
───────────────────────────────────────────────
10. GameEngine (после задержки 3 сек) → showMatchResults()
    ↓
11. GameController.showMatchResults()  ← ПРЯМОЙ ВЫЗОВ!
    ↓
12. Main.showMatchResults(gameState, isServer)
    ↓
13. ResultsScreenController.setGameState(gameState)
    ↓
14. ResultsScreenController.displayResults()
    Клиентская сторона при получении результата:
    text
    ШАГ 1: Получение сообщения от сервера
    ───────────────────────────────────────────────
1. GameClient получает JSON сообщение
2. NetworkManager.handleMessage(ROUND_RESULT, "2")
3. GameController.handleRoundResult(2)

ШАГ 2: Обработка на клиенте
───────────────────────────────────────────────
4. GameEngine.handleRoundResult(2) ← специальный метод!
    - Если раунд еще не завершен локально: endRound(2)
    - Если уже завершен: сверяет результаты
    - Выводит: "Клиент получил результат раунда: 2"

ШАГ 3: Синхронизация состояния
───────────────────────────────────────────────
5. Клиент корректирует свой gameState согласно серверу
6. Обновляется UI (счет, победитель раунда)
